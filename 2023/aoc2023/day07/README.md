# Advent of Code 2023 Day 7

Link: <https://adventofcode.com/2023/day/7>

## Part 1

### Card classification

I started by generating a HashMap of the unique cards and how many times they were found in the line:

```rust
use std::collections::HashMap;

let mut mapping: HashMap<char, u8> = HashMap::new();
for foo in cards.chars() {
    let val = mapping.entry(foo).or_insert(0);
    *val += 1;
}
```

From there we generate a Vector of those `u8` values only, then sort it:

```rust
let mut simplified: Vec<u8> = mapping.iter().map(|(_,v)| *v).collect();
simplified.sort();
```

This results in a small Vec in the form of i.e. `[1, 1, 3]`. This indicates 2 distinct cards and 3 that are matches to each other. This match up aligns with the "Three of a kind" win.

With that in place, it's a simple matter of mapping each type of winning hand to some value we can use for sorting later:

```rust
match simplified[..] {
    // Five of a kind: all cards are the same
    [5] => 7,
    // Four of a kind: 4 cards are the same, one is different
    [1, 4] => 6,
    // Full house: 3 are the same, 2 are a second type
    [2, 3] => 5,
    // Three of a kind: 3 are the same, the other 2 are both distinct
    [1, 1, 3] => 4,
    // Two pair: 2 are one type, 2 are another type, and the final is a distinct third type
    [1, 2, 2] => 3,
    // One pair: 2 are one type, the remaining 3 are all distinct types.
    [1, 1, 1, 2] => 2,
    // High card: all cards are distinct
    [1, 1, 1, 1, 1] => 1,
    // Should not hit the default case, but it's there.
    _ => 0,
}
```

### Card hand sort keys

The problem calls for stronger hands of the same type to rank higher, based solely on the left-most strongest card between them. This sounds like a job for lexicographical sorting! So we just need to convert the hand of cards into a string that sorts properly, creating a sorting key.

Since `2` is the weakest, we assign it to `A`; `3` becomes `B`; and so on, up to the Ace, `A`, assigned to `M` in the key:

```rust
fn card_sort_str(cards: &str) -> String {
    cards.chars().map(|c| match c {
        '2' => 'A',
        '3' => 'B',
        '4' => 'C',
        '5' => 'D',
        '6' => 'E',
        '7' => 'F',
        '8' => 'G',
        '9' => 'H',
        'T' => 'I',
        'J' => 'J',
        'Q' => 'K',
        'K' => 'L',
        'A' => 'M',
        _ => c,
    }).collect::<Vec<char>>().iter().collect()
}
```

Combined with the `hand_type` (returned by `classify_card`, defined by the previous section), we create one sort key with `format!`:

```rust
format!("{}{}", hand_type, card_sort_str(cards))
```

### Putting it together

The final solve stores data for the cards in a `CardData` struct:

```rust
struct CardData {
    _cards: String,
    _hand_type: u8,
    bid: u32,
    sort_key: String,
}
```

...which we push into a Vec as we process each line from the input:

```rust
let mut card_data: Vec<CardData> = Vec::new();

for line in contents {
    // Parse data from this line
    let (cards, bid) = line.trim().split_once(' ').expect("Failed to split the things");
    let bid: u32 = bid.parse().expect("Failed to parse bid number.");

    // Classify our hand type
    let hand_type: u8 = classify_card(cards);

    // Generate our CardData and push it onto the Vec
    card_data.push(CardData {
        _cards: cards.to_string(),
        _hand_type: hand_type,
        bid,
        sort_key: format!("{}{}", hand_type, card_sort_str(cards))
    })
}
```

...and then sort that Vec by our generated `sort_key` value:

```rust
// Sort by our `sort_key` (need to clone it to copy the value here)
card_data.sort_by_key(|c| c.sort_key.clone());
```

Once this is in place, we can iterate through the `card_data` Vec with `.iter().enumerate()` in order to get indexes, which we'll need to use as rank values (index + 1):

```rust
let mut total: u64 = 0;

for (idx, data) in card_data.iter().enumerate() {
    total += ((idx as u64) + 1) * (data.bid as u64);
}

println!(">> {total}");
```

And that's our answer! On to Part 2

## Part 2

The addition of Jokers as the `J` value has two implications:

- The `hand_type` classification of a set of cards will change based on the number of Jokers present.
- The sort key generated by `card_sort_str` needs to move `J` values *down* to sort hands correctly.

The latter is a very simple change, moving `J` down to the first position and shuffling others around:

```rust
fn card_sort_str(cards: &str) -> String {
    cards.chars().map(|c| match c {
        // I'm over here now!
        'J' => 'A',
        '2' => 'B',
        '3' => 'C',
        '4' => 'D',
        '5' => 'E',
        '6' => 'F',
        '7' => 'G',
        '8' => 'H',
        '9' => 'I',
        'T' => 'J',
        // Everything above here has shifted
        'Q' => 'K',
        'K' => 'L',
        'A' => 'M',
        _ => c,
    }).collect::<Vec<char>>().iter().collect()
}
```

On to the classification change

### Hands possible with Jokers

I stared at the examples for a while and posited a theory: the strongest hand possible from any hand with Jokers can be found by simply adding the number of Jokers to the *highest* value of other distinct cards.

For example, the sample hand `T55J5` contains 1 `T`, 3 `5`s, and 1 Joker. First we `.filter()` these `J` values out of our mapping as we collect the Vec of `simplified` counts:

```rust
let mut simplified: Vec<u8> = mapping
    .iter()
    // Don't include the number of `J`s in this vec
    .filter(|(&k, _)| k != 'J')
    .map(|(_, v)| *v)
    .collect();
simplified.sort();
```

In this example, `simplified` will be `[1, 3]`. Considering how to score the 1 Joker, there are three possible outcomes:

- As a distinct card, `[1, 1, 3]`, creating "Three of a Kind" (type 4);
- Combined with the `T`, `[2, 3]`, creating "Full House" (type 5); OR
- Combined with the `5`s, `[1, 4]`, creating "Four of a Kind" (type 6).

Type 6 is the strongest hand possible, obtained by adding the Joker (`1`) to the highest count of cards in the set (`3`).

I considered this for a few other scenarios until I was confident that this works out, then applied it. We test to see if the `mapping` contains any `J` values, then add the count of those Jokers to the *last* element in the `simplified` Vec (after sorting, this last value is always the highest):

```rust
if let Some(&jokers) = mapping.get(&'J') {
        if let Some(last_element) = simplified.last_mut() {
            *last_element += jokers;
        } else {
            // The vector was empty: this hand was all jokers!
            // Push our Five of a kind identifier, instead:
            simplified.push(5);
        }
    }
```

The `else` condition came about accidentally. I came out with an incorrect answer, and after digging through I realized I had a hand of `JJJJJ` that had been ranked `0` (which comes out from a default `_` arm of the `match`). This had to result from the Vec being *empty* because we had filtered all those `J`s out of consideration. Thus, it was just a matter of pushing a literal `5` to make classification work out.

With no other changes needed for parsing or collecting total scores, this resulted in the correct answer! ðŸ’ª
